/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ObsidianEmacsKeymap
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// node_modules/@replit/codemirror-emacs/dist/index.js
var import_state = require("@codemirror/state");
var import_view = require("@codemirror/view");
var commands = __toESM(require("@codemirror/commands"), 1);
var import_autocomplete = require("@codemirror/autocomplete");
var import_search = require("@codemirror/search");
var Piece = class {
  constructor(left, top, height, className, letter, partial) {
    this.left = left;
    this.top = top;
    this.height = height;
    this.className = className;
    this.letter = letter;
    this.partial = partial;
  }
  draw() {
    let elt = document.createElement("div");
    elt.className = this.className;
    this.adjust(elt);
    return elt;
  }
  adjust(elt) {
    elt.style.left = this.left + "px";
    elt.style.top = this.top + "px";
    elt.style.height = this.height + "px";
    elt.style.lineHeight = this.height + "px";
    elt.style.color = this.partial ? "transparent" : "";
    elt.className = this.className;
    elt.textContent = this.letter;
  }
  eq(p) {
    return this.left == p.left && this.top == p.top && this.letter == p.letter && this.height == p.height && this.className == p.className;
  }
};
var BlockCursorPlugin = class {
  constructor(view) {
    this.view = view;
    this.rangePieces = [];
    this.cursors = [];
    this.measureReq = { read: this.readPos.bind(this), write: this.drawSel.bind(this) };
    this.cursorLayer = view.scrollDOM.appendChild(document.createElement("div"));
    this.cursorLayer.className = "cm-cursorLayer cm-vimCursorLayer";
    this.cursorLayer.setAttribute("aria-hidden", "true");
    view.requestMeasure(this.measureReq);
    this.setBlinkRate();
  }
  setBlinkRate() {
    this.cursorLayer.style.animationDuration = 1200 + "ms";
  }
  update(update) {
    if (update.selectionSet || update.geometryChanged || update.viewportChanged) {
      this.view.requestMeasure(this.measureReq);
      this.cursorLayer.style.animationName = this.cursorLayer.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink";
    }
  }
  scheduleRedraw() {
    this.view.requestMeasure(this.measureReq);
  }
  readPos() {
    let { state } = this.view;
    let cursors = [];
    for (let r of state.selection.ranges) {
      let prim = r == state.selection.main;
      let piece = measureCursor(null, this.view, r, prim);
      if (piece)
        cursors.push(piece);
    }
    return { cursors };
  }
  drawSel({ cursors }) {
    if (cursors.length != this.cursors.length || cursors.some((c, i) => !c.eq(this.cursors[i]))) {
      let oldCursors = this.cursorLayer.children;
      if (oldCursors.length !== cursors.length) {
        this.cursorLayer.textContent = "";
        for (const c of cursors)
          this.cursorLayer.appendChild(c.draw());
      } else {
        cursors.forEach((c, idx) => c.adjust(oldCursors[idx]));
      }
      this.cursors = cursors;
    }
  }
  destroy() {
    this.cursorLayer.remove();
  }
};
var themeSpec = {
  ".cm-line": {
    "& ::selection": { backgroundColor: "transparent !important" },
    "&::selection": { backgroundColor: "transparent !important" },
    caretColor: "transparent !important"
  },
  ".cm-fat-cursor": {
    position: "absolute",
    background: "#ff9696",
    border: "none",
    whiteSpace: "pre"
  },
  "&:not(.cm-focused) .cm-fat-cursor": {
    background: "none",
    outline: "solid 1px #ff9696"
  }
};
var hideNativeSelection = /* @__PURE__ */ import_state.Prec.highest(/* @__PURE__ */ import_view.EditorView.theme(themeSpec));
function getBase(view) {
  let rect = view.scrollDOM.getBoundingClientRect();
  let left = view.textDirection == import_view.Direction.LTR ? rect.left : rect.right - view.scrollDOM.clientWidth;
  return { left: left - view.scrollDOM.scrollLeft, top: rect.top - view.scrollDOM.scrollTop };
}
function measureCursor(cm, view, cursor, primary) {
  let head = cursor.head;
  var hCoeff = 1;
  let pos = view.coordsAtPos(head, 1);
  if (!pos)
    return null;
  let base = getBase(view);
  let letter = head < view.state.doc.length && view.state.sliceDoc(head, head + 1);
  if (!letter || letter == "\n" || letter == "\r")
    letter = "\xA0";
  let h = pos.bottom - pos.top;
  return new Piece(pos.left - base.left, pos.top - base.top + h * (1 - hCoeff), h * hCoeff, primary ? "cm-fat-cursor cm-cursor-primary" : "cm-fat-cursor cm-cursor-secondary", letter, hCoeff != 1);
}
var emacsStyle = /* @__PURE__ */ import_view.EditorView.theme({
  ".cm-emacsMode .cm-cursorLayer:not(.cm-vimCursorLayer)": {
    display: "none"
  },
  ".cm-vim-panel": {
    padding: "5px 10px",
    backgroundColor: "#fffa8f",
    fontFamily: "monospace"
  },
  ".cm-vim-panel input": {
    border: "none",
    outline: "none",
    backgroundColor: "#fffa8f"
  }
});
var emacsPlugin = /* @__PURE__ */ import_view.ViewPlugin.fromClass(class {
  constructor(view) {
    this.status = "";
    this.view = view;
    this.em = new EmacsHandler(view);
    this.blockCursor = new BlockCursorPlugin(view);
    this.view.scrollDOM.classList.add("cm-emacsMode");
  }
  update(update) {
    if (update.docChanged) {
      this.em.$emacsMark = null;
      this.em.updateMarksOnChange(update.changes);
    }
    this.blockCursor.update(update);
  }
  destroy() {
    this.view.scrollDOM.classList.remove("cm-emacsMode");
    this.blockCursor.destroy();
  }
}, {
  eventHandlers: {
    mousedown: function() {
      this.em.$emacsMark = null;
    }
  },
  provide: (plugin) => {
    return import_view.keymap.of([
      {
        any: function(view, e) {
          var _a;
          return !!((_a = view.plugin(plugin)) === null || _a === void 0 ? void 0 : _a.em.handleKeyboard(e));
        }
      }
    ]);
  }
});
var showVimPanel = /* @__PURE__ */ import_state.StateEffect.define();
var vimPanelState = /* @__PURE__ */ import_state.StateField.define({
  create: () => false,
  update(value, tr) {
    for (let e of tr.effects)
      if (e.is(showVimPanel))
        value = e.value;
    return value;
  },
  provide: (f) => {
    return import_view.showPanel.from(f, (on) => on ? createVimPanel : null);
  }
});
function createVimPanel(view) {
  let dom = document.createElement("div");
  dom.className = "cm-vim-panel";
  return { top: false, dom };
}
function emacs(options = {}) {
  return [
    emacsStyle,
    emacsPlugin,
    hideNativeSelection,
    vimPanelState
  ];
}
var specialKey = {
  Return: "Return",
  Escape: "Esc",
  Insert: "Ins",
  ArrowLeft: "Left",
  ArrowRight: "Right",
  ArrowUp: "Up",
  ArrowDown: "Down",
  Enter: "Return",
  Divide: "/",
  Slash: "/",
  Multiply: "*",
  Subtract: "-",
  Minus: "-",
  Equal: "="
};
var ignoredKeys = { Shift: 1, Alt: 1, Command: 1, Control: 1, CapsLock: 1 };
var commandKeyBinding = {};
var EmacsHandler = class {
  constructor(view) {
    this.view = view;
    this.$data = {
      count: 0,
      keyChain: "",
      lastCommand: ""
    };
    this.$emacsMarkRing = [];
    this.$emacsMark = null;
  }
  static bindKey(keyGroup, command) {
    keyGroup.split("|").forEach(function(binding) {
      let chain = "";
      let parts = binding.split(/\s+/);
      parts.forEach(function(keyGroup2, index) {
        let modifiers = keyGroup2.split(/-(?=.)/);
        let key = modifiers.pop();
        if (modifiers.length) {
          chain += modifiers.sort().join("-") + "-";
        }
        chain += key;
        if (index === parts.length - 1) {
          commandKeyBinding[chain] = command;
        } else {
          commandKeyBinding[chain] = "null";
          chain += " ";
        }
      });
    });
  }
  static getKey(e) {
    var code = e.code;
    var key = e.key;
    if (ignoredKeys[key])
      return ["", "", ""];
    if (code.length > 1) {
      if (code[0] == "N")
        code = code.replace(/^Numpad/, "");
      if (code[0] == "K")
        code = code.replace(/^Key/, "");
    }
    code = specialKey[code] || code;
    if (code.length == 1)
      code = code.toLowerCase();
    var modifier = "";
    if (e.ctrlKey) {
      modifier += "C-";
    }
    if (e.metaKey) {
      modifier += "CMD-";
    }
    if (e.altKey) {
      modifier += "M-";
    }
    if (e.shiftKey) {
      modifier += "S-";
    }
    return [code, modifier, key];
  }
  static addCommands(commands2) {
    Object.keys(commands2).forEach(function(name) {
      var command = commands2[name];
      if (typeof command == "function") {
        command = { exec: command };
      }
      EmacsHandler.commands[name] = command;
    });
  }
  static execCommand(command, handler, args, count = 1) {
    var commandResult = void 0;
    if (typeof command === "function") {
      for (var i = 0; i < count; i++)
        command(handler.view);
    } else if (command === "null")
      ;
    else if (command.exec) {
      if (count > 1 && command.handlesCount) {
        if (!args)
          args = {};
        if (typeof args === "object")
          args.count = count;
        count = 1;
      }
      for (var i = 0; i < count; i++)
        commandResult = command.exec(handler, args || {});
    } else {
      throw new Error("missformed command");
    }
    return commandResult;
  }
  handleKeyboard(e) {
    var keyData = EmacsHandler.getKey(e);
    var result = this.findCommand(keyData);
    if (result && result.command) {
      var commandResult = EmacsHandler.execCommand(result.command, this, result.args, result.count);
      if (commandResult === false)
        return;
    }
    return result;
  }
  findCommand([key, modifier, text]) {
    if (!key)
      return void 0;
    var editor = this;
    var data = this.$data;
    if (!modifier && key.length == 1) {
      editor.pushEmacsMark();
      if (data.count) {
        var str = new Array(data.count + 1).join(text);
        data.count = null;
        return { command: "insertstring", args: str };
      }
    }
    if (modifier == "C-" || data.count) {
      var count = parseInt(key[key.length - 1]);
      if (typeof count === "number" && !isNaN(count)) {
        data.count = Math.max(data.count || 0, 0);
        data.count = 10 * data.count + count;
        return { command: "null" };
      }
    }
    if (modifier)
      key = modifier + key;
    if (data.keyChain)
      key = data.keyChain += " " + key;
    var command = commandKeyBinding[key];
    data.keyChain = command == "null" ? key : "";
    if (!command)
      return void 0;
    if (command === "null")
      return { command: "null" };
    if (command === "universalArgument") {
      data.count = -4;
      return { command: "null" };
    }
    var args;
    if (typeof command !== "string") {
      args = command.args;
      if (command.command)
        command = command.command;
    }
    if (command === "insertstring" || command === commands.splitLine || command === commands.toggleComment) {
      editor.pushEmacsMark();
    }
    if (typeof command === "string") {
      command = EmacsHandler.commands[command];
      if (!command)
        return void 0;
    }
    if (!command.readOnly && !command.isYank)
      data.lastCommand = null;
    var count = data.count || 1;
    if (data.count)
      data.count = 0;
    return { command, args, count };
  }
  showCommandLine(text) {
    console.error("TODO");
  }
  updateMarksOnChange(change) {
    if (this.$emacsMark) {
      this.$emacsMark = this.updateMark(this.$emacsMark, change);
    }
    this.$emacsMarkRing = this.$emacsMarkRing.map((x) => {
      return this.updateMark(x, change);
    }).filter(Boolean);
  }
  updateMark(mark, change) {
    if (!mark)
      return;
    var updated = mark.map(function(x) {
      return change.mapPos(x, 1, import_state.MapMode.TrackDel);
    }).filter((x) => x != null);
    return updated.length == 0 ? null : updated;
  }
  emacsMark() {
    return this.$emacsMark;
  }
  setEmacsMark(p) {
    this.$emacsMark = p;
  }
  pushEmacsMark(p, activate) {
    var prevMark = this.$emacsMark;
    if (prevMark)
      this.$emacsMarkRing.push(prevMark);
    if (!p || activate)
      this.setEmacsMark(p);
    else
      this.$emacsMarkRing.push(p);
  }
  popEmacsMark() {
    var mark = this.emacsMark();
    if (mark) {
      this.setEmacsMark(null);
      return mark;
    }
    return this.$emacsMarkRing.pop();
  }
  getLastEmacsMark() {
    return this.$emacsMark || this.$emacsMarkRing.slice(-1)[0];
  }
  getCopyText() {
    var state = this.view.state;
    return state.selection.ranges.map((r) => state.sliceDoc(r.from, r.to)).join("\n");
  }
  clearSelection() {
    var view = this.view;
    var selection = view.state.selection;
    var isEmpty = !selection.ranges.some((r) => r.from != r.to);
    if (isEmpty)
      return false;
    var newRanges = selection.ranges.map((x) => {
      return import_state.EditorSelection.range(x.head, x.head);
    });
    view.dispatch({
      selection: import_state.EditorSelection.create(newRanges, selection.mainIndex)
    });
    return true;
  }
  onPaste(text) {
    var view = this.view;
    var selection = view.state.selection;
    var linesToInsert;
    if (selection.ranges.length > 1) {
      var lines = text.split("\n");
      if (lines.length == selection.ranges.length) {
        linesToInsert = lines;
      }
    }
    var i = 0;
    var specs = view.state.changeByRange((range) => {
      var toInsert = linesToInsert ? linesToInsert[i] : text;
      i++;
      return {
        changes: { from: range.from, to: range.to, insert: toInsert },
        range: import_state.EditorSelection.cursor(range.from + toInsert.length)
      };
    });
    view.dispatch(specs);
  }
};
EmacsHandler.commands = {};
var emacsKeys = {
  // movement
  "Up|C-p": { command: "goOrSelect", args: [commands.cursorLineUp, commands.selectLineUp] },
  "Down|C-n": { command: "goOrSelect", args: [commands.cursorLineDown, commands.selectLineDown] },
  "Left|C-b": { command: "goOrSelect", args: [commands.cursorCharBackward, commands.selectCharBackward] },
  "Right|C-f": { command: "goOrSelect", args: [commands.cursorCharForward, commands.selectCharForward] },
  "C-Left|M-b": { command: "goOrSelect", args: [commands.cursorGroupLeft, commands.selectGroupLeft] },
  "C-Right|M-f": { command: "goOrSelect", args: [commands.cursorGroupRight, commands.selectGroupRight] },
  "Home|C-a": { command: "goOrSelect", args: [commands.cursorLineStart, commands.selectLineStart] },
  "End|C-e": { command: "goOrSelect", args: [commands.cursorLineEnd, commands.selectLineEnd] },
  "C-Home|S-M-,": { command: "goOrSelect", args: [commands.cursorDocStart, commands.selectDocStart] },
  "C-End|S-M-.": { command: "goOrSelect", args: [commands.cursorDocEnd, commands.selectDocEnd] },
  // selection
  "S-Up|S-C-p": commands.selectLineUp,
  "S-Down|S-C-n": commands.selectLineDown,
  "S-Left|S-C-b": commands.selectCharBackward,
  "S-Right|S-C-f": commands.selectCharForward,
  "S-C-Left|S-M-b": commands.selectGroupBackward,
  "S-C-Right|S-M-f": commands.selectGroupForward,
  "S-Home|S-C-a": commands.selectLineStart,
  "S-End|S-C-e": commands.selectLineEnd,
  "S-C-Home": commands.selectDocStart,
  "S-C-End": commands.selectDocEnd,
  "C-l": "recenterTopBottom",
  "M-s": "centerSelection",
  "M-g": "gotoline",
  "C-x C-p|C-x h": commands.selectAll,
  "PageDown|C-v|C-Down": { command: "goOrSelect", args: [commands.cursorPageDown, commands.selectPageDown] },
  "PageUp|M-v|C-Up": { command: "goOrSelect", args: [commands.cursorPageUp, commands.selectPageDown] },
  "S-C-Down": commands.selectPageDown,
  "S-C-Up": commands.selectPageUp,
  // TODO use iSearch
  "C-s": import_search.openSearchPanel,
  "C-r": import_search.openSearchPanel,
  "M-C-s": "findnext",
  "M-C-r": "findprevious",
  "S-M-5": "replace",
  // basic editing
  "Backspace": commands.deleteCharBackward,
  "Delete|C-d": commands.deleteCharForward,
  "Return|C-m": { command: "insertstring", args: "\n" },
  "C-o": commands.splitLine,
  "M-d|C-Delete": { command: "killWord", args: "right" },
  "C-Backspace|M-Backspace|M-Delete": { command: "killWord", args: "left" },
  "C-k": "killLine",
  "M-h": "selectParagraph",
  "M-@|M-S-2": "markWord",
  "C-y|S-Delete": "yank",
  "M-y": "yankRotate",
  "C-g": "keyboardQuit",
  "C-w|C-S-w": "killRegion",
  "M-w": "killRingSave",
  "C-Space": "setMark",
  "C-x C-x": "exchangePointAndMark",
  "C-t": commands.transposeChars,
  "M-u": { command: "changeCase", args: { dir: 1 } },
  "M-l": { command: "changeCase", args: { dir: -1 } },
  "C-x C-u": { command: "changeCase", args: { dir: 1, region: true } },
  "C-x C-l": { command: "changeCase", args: { dir: 1, region: true } },
  "M-/": import_autocomplete.startCompletion,
  "C-u": "universalArgument",
  "M-;": commands.toggleComment,
  "C-/|C-x u|S-C--|C-z": commands.undo,
  "S-C-/|S-C-x u|C--|S-C-z": commands.redo,
  // vertical editing
  "C-x r": "selectRectangularRegion",
  "M-x": { command: "focusCommandLine", args: "M-x " },
  // todo
  // "C-x C-t" "M-t" "M-c" "F11" "C-M- "M-q"
  "Esc": "unsetTransientMark"
};
for (let i in emacsKeys) {
  /* @__PURE__ */ EmacsHandler.bindKey(i, emacsKeys[i]);
}

// main.ts
var ObsidianEmacsKeymap = class extends import_obsidian.Plugin {
  async onload() {
    this.editorExtensions = [emacs()];
    this.registerEditorExtension(this.editorExtensions);
  }
  async onunload() {
    this.editorExtensions.splice(0, this.editorExtensions.length);
  }
};
